//go:build darwin && cgo && !nometal
// +build darwin,cgo,!nometal

package main

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Metal -framework Foundation
#import <Metal/Metal.h>
#import <Foundation/Foundation.h>

struct MetalVertex {
    float position[3];
    float height;
    int plateID;
};

struct MetalPlate {
    float center[3];
    float velocity[3];
    int plate_type;
};

typedef struct {
    id<MTLDevice> device;
    id<MTLCommandQueue> commandQueue;
    id<MTLComputePipelineState> pipelineState;
} MetalCompute;

MetalCompute* initMetal() {
    @autoreleasepool {
        id<MTLDevice> device = MTLCreateSystemDefaultDevice();
        if (!device) {
            return NULL;
        }
        
        NSString *shaderSource = @"#include <metal_stdlib>\n"
        "using namespace metal;\n"
        "struct Vertex {\n"
        "    float3 position;\n"
        "    float height;\n"
        "    int plateID;\n"
        "};\n"
        "struct Plate {\n"
        "    float3 center;\n"
        "    float3 velocity;\n"
        "    int plate_type;\n"
        "};\n"
        "kernel void updateTectonics(device Vertex* vertices [[buffer(0)]],\n"
        "                           constant Plate* plates [[buffer(1)]],\n"
        "                           constant float& deltaTime [[buffer(2)]],\n"
        "                           uint index [[thread_position_in_grid]]) {\n"
        "    if (index >= 10242) return;\n"
        "    int plateID = vertices[index].plateID;\n"
        "    if (plateID < 0 || plateID >= 32) return;\n"
        "    float3 velocity = plates[plateID].velocity;\n"
        "    float velocityMag = length(velocity);\n"
        "    float uplift = velocityMag * 1000.0f * 0.00001f;\n"
        "    if (plates[plateID].plate_type == 0) {\n"
        "        vertices[index].height += uplift;\n"
        "    } else {\n"
        "        vertices[index].height -= uplift * 0.5f;\n"
        "    }\n"
        "    vertices[index].height = clamp(vertices[index].height, -0.02f, 0.02f);\n"
        "}";
        
        NSError *error = nil;
        id<MTLLibrary> library = [device newLibraryWithSource:shaderSource options:nil error:&error];
        if (!library) {
            return NULL;
        }
        
        id<MTLFunction> function = [library newFunctionWithName:@"updateTectonics"];
        if (!function) {
            return NULL;
        }
        
        id<MTLComputePipelineState> pipelineState = [device newComputePipelineStateWithFunction:function error:&error];
        if (!pipelineState) {
            return NULL;
        }
        
        id<MTLCommandQueue> commandQueue = [device newCommandQueue];
        if (!commandQueue) {
            return NULL;
        }
        
        MetalCompute* compute = malloc(sizeof(MetalCompute));
        compute->device = (__bridge void*)device;
        compute->commandQueue = (__bridge void*)commandQueue;
        compute->pipelineState = (__bridge void*)pipelineState;
        
        return compute;
    }
}

int runMetalCompute(MetalCompute* compute, struct MetalVertex* vertices, struct MetalPlate* plates, int numVertices) {
    if (!compute) return 0;
    
    @autoreleasepool {
        id<MTLDevice> device = (__bridge id<MTLDevice>)compute->device;
        id<MTLCommandQueue> commandQueue = (__bridge id<MTLCommandQueue>)compute->commandQueue;
        id<MTLComputePipelineState> pipelineState = (__bridge id<MTLComputePipelineState>)compute->pipelineState;
        
        size_t vertexSize = numVertices * sizeof(struct MetalVertex);
        size_t plateSize = 32 * sizeof(struct MetalPlate);
        
        id<MTLBuffer> vertexBuffer = [device newBufferWithBytes:vertices length:vertexSize options:MTLResourceStorageModeShared];
        id<MTLBuffer> plateBuffer = [device newBufferWithBytes:plates length:plateSize options:MTLResourceStorageModeShared];
        
        id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];
        id<MTLComputeCommandEncoder> encoder = [commandBuffer computeCommandEncoder];
        
        [encoder setComputePipelineState:pipelineState];
        [encoder setBuffer:vertexBuffer offset:0 atIndex:0];
        [encoder setBuffer:plateBuffer offset:0 atIndex:1];
        
        MTLSize threadsPerGroup = MTLSizeMake(256, 1, 1);
        MTLSize numThreadgroups = MTLSizeMake((numVertices + 255) / 256, 1, 1);
        
        [encoder dispatchThreadgroups:numThreadgroups threadsPerThreadgroup:threadsPerGroup];
        [encoder endEncoding];
        
        [commandBuffer commit];
        [commandBuffer waitUntilCompleted];
        
        // Copy results back
        memcpy(vertices, [vertexBuffer contents], vertexSize);
        
        return 1;
    }
}

void cleanupMetal(MetalCompute* compute) {
    if (compute) {
        free(compute);
    }
}
*/
import "C"
import (
	"fmt"
	"unsafe"
)

type MetalGPU struct {
	compute *C.MetalCompute
	enabled bool
}

var metalGPU *MetalGPU

func initMetalGPU() *MetalGPU {
	compute := C.initMetal()
	if compute == nil {
		return &MetalGPU{enabled: false}
	}
	
	return &MetalGPU{
		compute: compute,
		enabled: true,
	}
}

func updateTectonicsMetal(planet Planet, deltaYears float64) Planet {
	if !metalGPU.enabled || len(planet.Vertices) == 0 || len(planet.Plates) == 0 {
		return updateTectonics(planet, deltaYears)
	}
	
	// Convert to Metal format
	vertices := make([]C.struct_MetalVertex, len(planet.Vertices))
	for i, v := range planet.Vertices {
		vertices[i].position[0] = C.float(v.Position.X)
		vertices[i].position[1] = C.float(v.Position.Y)
		vertices[i].position[2] = C.float(v.Position.Z)
		vertices[i].height = C.float(v.Height)
		vertices[i].plateID = C.int(v.PlateID)

	}
	
	plates := make([]C.struct_MetalPlate, 32)
	for i, p := range planet.Plates {
		if i >= 32 { break }
		plates[i].center[0] = C.float(p.Center.X)
		plates[i].center[1] = C.float(p.Center.Y)
		plates[i].center[2] = C.float(p.Center.Z)
		plates[i].velocity[0] = C.float(p.Velocity.X)
		plates[i].velocity[1] = C.float(p.Velocity.Y)
		plates[i].velocity[2] = C.float(p.Velocity.Z)
		if p.Type == Continental {
			plates[i].plate_type = 0
		} else {
			plates[i].plate_type = 1
		}

	}
	
	success := C.runMetalCompute(
		metalGPU.compute,
		(*C.struct_MetalVertex)(unsafe.Pointer(&vertices[0])),
		(*C.struct_MetalPlate)(unsafe.Pointer(&plates[0])),
		C.int(len(planet.Vertices)),
	)
	
	if success == 0 {
		fmt.Println("Metal compute failed, falling back to CPU")
		return updateTectonics(planet, deltaYears)
	}
	
	// Copy results back
	for i := range planet.Vertices {
		planet.Vertices[i].Height = float64(vertices[i].height)
		planet.Vertices[i].Position = planet.Vertices[i].Position.Normalize()
	}
	
	planet.GeologicalTime += deltaYears
	return planet
}

func init() {
	metalGPU = initMetalGPU()
}